\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage{csquotes}
\usepackage[vmargin=25mm, hmargin=20mm]{geometry}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{easy-todo}
\usepackage{graphicx}
\usepackage{xspace}
% \usepackage{float}
% \usepackage{pgfplots}
% \usepgfplotslibrary{colorbrewer}
% \pgfplotsset{compat = 1.18} 
% \usetikzlibrary{pgfplots.statistics, pgfplots.colorbrewer} 
% \usepackage{pgfplotstable}
\usepackage{listings}
\lstset{
    backgroundcolor=\color[RGB]{240, 240, 240},   
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    aboveskip=10pt
}
\usepackage{listings-rust}

\renewcommand{\footnoterule}{%
  \kern 10pt % Increased spacing above delimiter
  \hrule width 0.8\columnwidth
  \kern 5pt
}

\usepackage[
    backend=biber,
    sorting=none,
    style=ieee,
    urldate=long,
    maxcitenames=2,
    mincitenames=1
]{biblatex}
\addbibresource{sources.bib}
\renewcommand*{\bibfont}{\footnotesize}

\usepackage{multicol}
\setlength{\columnsep}{13mm}

% \usepackage{hypcap}
% \usepackage{caption}
% \captionsetup{
%     justification=centerlast,
%     font=small,
%     labelfont=sc,
%     margin=5pt,
%     belowskip=15pt
% }
% \DeclareCaptionType{listing}[Listing][List of Listings]

\title{%
    \vspace{50px}%
    \Huge \proj : A Stateful Fuzzer\\for the TCP/IP Stack of the Zephyr
    \vspace{250px}%
}

\author{%
    Valentin Huber\vspace{5px}\\%
    \small at \href{https://www.cydcampus.admin.ch/}{Cyber Defence Campus}\\%
    \small and \href{https://www.zhaw.ch/en/engineering/institutes-centres/init/}{Institute of Computer Science at ZHAW}\\%
    \small \href{mailto://contact@valentinhuber.me}{contact@valentinhuber.me}%
    \vspace{10px}
}

\date{\today}

\DeclareFieldFormat*{citetitle}{\textit{#1}}
\hfuzz=50px
\hbadness=10000
\newcommand{\code}[2][]{\lstinline[language=#1, breaklines=false, basicstyle=\ttfamily]{#2}}
\newcommand{\proj}{FuZetwork\xspace}
\let\savedCite=\cite
\renewcommand{\cite}{\unskip~\savedCite}
\renewcommand{\arraystretch}{1.5} % Increase table padding


\begin{document}
\pagenumbering{gobble}
\maketitle

\clearpage\newpage
\begin{center}
  \begin{minipage}{0.8\textwidth}
    \vspace{70px}

    \begin{abstract}
      \lipsum[1]\lipsum[2]\lipsum[3]
    \end{abstract}
  \end{minipage}

  \vspace{70px}

  \begin{minipage}{0.7\textwidth}
    \textbf{Keywords}: Software Testing, Fuzzing, Stateful Fuzzing, Zephyr, LibAFL.
  \end{minipage}
\end{center}

\clearpage\newpage
\tableofcontents
\vspace{30px}
\pagenumbering{arabic}
\clearpage\newpage

\begin{multicols}{2}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Introduction %%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Introduction}

  Zephyr is an open-source real-time operating system hosted by the Linux Foundation.\cite{ZephyrAbout} Real-time operating systems allow programers to define time constraints on their code, which are then guaranteed by the process scheduler. To do this, processes have to be verifiably complete within a constant maximal time or fail safely. This is particularly important for safety-critical systems where delays in computation can pose serious risk, such as control of a robot.\cite{RTOSWiki} Zephyr is used in a wide range of products, including large industrial equipments such as wind turbines, medtech devices such as hearing aids, laptops, embedded devices such as emergency water detectors.\cite{ZephyrUsedIn}

  Zephyr projects typically connect to other devices or the internet using one of the operating system's networking libraries, such as a custom-built TCP/IP stack. Since many of these devices need access to the internet, any defect in the network stack is comparatively likely to be remotely exploitable and thus critical. In combination with the potentially dangerous devices Zephyr runs on, this makes the correctness of these parts of Zephyr paramount.\todo{Too much opinion?}

  Fuzzing has been established as a widely used technique\cite{Demystifying} to find software defects by repeatedly running a certain program under test (PUT) with a wide range of inputs and observing the execution for illegal program states such as crashes. Ever since its inception in the nominal work by \citeauthor{UNIX}\cite{UNIX}, who used random data to test Unix utilities, many improvements to fuzzing have been introduced to the state of the art. Among many others (Google Scholar retrieves more than 60,000 results in a search for \textquote{fuzz testing}\cite{GoogleScholarFuzzing}) include observing the program execution to guide the fuzzer when selecting the next input to test, or improved oracles such as memory sanitizers. However, fuzzing the network stack of an operating system poses three challenges: (1) they are deeply integrated with the operating system, (2) they require highly structured input data, and (3) they have internal state. These challenges are further elaborated in Section~\ref{Background:FuzzingNetworkStacksIsHard}.

  This thesis presents \proj, a proof-of-concept fuzzer using advanced input representation and mutation techniques, stateful feedback, and approaches to effectively test an unreliably PUT targeting the TCP/IP stack of Zephyr. It is structured as follows:

  \begin{itemize}
    \item Section~\ref{Background} presents further background on fuzzing in general and targeting TCP/IP systems in particular,
    \item Section~\ref{RelatedWorks} explores related works,
    \item Section~\ref{Implementation} explains the different techniques used in \proj, along with how they were implemented,
    \item Section~\ref{Results} presents the results achieved in this project,
    \item Section~\ref{Discussion} discusses the implication of those results on the effectiveness of \proj, and
    \item Section~\ref{Conclusion} summarizes the findings of this thesis.
  \end{itemize}

  \subsection{Quotes, TODO: Integrate}

  \textquote{The input language of a stateful system consists of two levels: (1) the language of the individual messages, which we will refer to as the message format, and (2) the language of traces, built on top of that. A description or specification of such an input language will usually come in two parts, one for each of the levels: for example, a context-free grammar for the message format and a finite state machine describing sequences of these messages. We will call the latter the state model or, if it is described as a state machine, the protocol state machine.}\cite{StatefulReview}


  \subsubsection{TCP/IP}
  Checksums such as in TCP/IP are challenging.\cite{StateOfTheArt} Approaches to deal with this include removing the program sections from the target program\cite{TFuzz}.

  \subsection{Contributions of this Project}
  A fuzzer that targets the TCP/IP stack of Zephyr, which
  \begin{itemize}
    \item employs a framework that allows running Zephyr as a native executable, removing the necessity of an emulation or translation layer,
    \item introduces a custom ethernet driver based on shared memory to make fuzzing parallelizable and performant,
    \item guides mutation based on coverage information and a heuristic to infer the state of the TCP state machine based on flags in the TCP header of responses from the server
  \end{itemize}
  This project further
  \begin{itemize}
    \item evaluates how different ways of using the feedback described above influence fuzzer performance,
    \item evaluates different ways of modelling the packets passed to the fuzzer,
    \item evaluates different approaches to mutating those, and
    \item introduces various performance optimizations to LibAFL
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Background %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Background}
  \label{Background}

  \subsection{Fuzzing techniques}
  \subsubsection{Generational Fuzzing and Mutation}
  \subsubsection{Feedback}
  \label{Background:Feedback}

  \subsection{Fuzzing Network Stacks Is Hard}
  \label{Background:FuzzingNetworkStacksIsHard}

  \subsubsection{Deep integration with OS}
  \begin{itemize}
    \item Environment/Hardware modelling necessary
    \item Usually, whole system needs to be run, which is a performance issue
    \item Instrumentation (Coverage, Sanitizers) is hard
  \end{itemize}

  \subsubsection{Network packets are highly structured}
  \label{Background:TcpIsStructured}
  \begin{itemize}
    \item Dependencies between data (length fields, checksums, etc.)
    \item Dependencies between packages (state in TCP)
  \end{itemize}

  \subsubsection{TCP Stacks Have an Internal State}
  \label{Background:TcpIsStateful}

  \citeauthor{StatefulReview} introduce a taxonomy of stateful fuzzing in which they define a stateful system as \textquote{a system that takes a sequence of messages as input, producing outputs along the way, and where each input may result in an internal state change}\cite{StatefulReview}. TCP stacks are such a stateful system. This thesis will further follow the naming convention outlined in their same work, reserving \textquote{the term message or input message for the individual input that the System Under Test (SUT) consumes at each step and the term trace for a sequence of such messages that make up the entire input.}\cite{StatefulReview}

  The fact that TCP is a stateful protocol increases the state space to be explored by the fuzzer dramatically, and the fuzzer may find it hard to reach 'deeper' states.\cite{StatefulReview} Indeed, stateful targets are listed among the remaining challenges in fuzzing by \citeauthor{ChallengesAndReflections} in their review paper.\cite{ChallengesAndReflections}

  This introduces two fundamental challenges on the architecture of the fuzzer:
  \begin{enumerate}
    \item To retain the ability to triage the software error found by the fuzzer, one needs the ability to repeatedly cause the same error. Since the PUT may be put into different states with each message, this means all previous interaction with a PUT instance need to be recorded, records which may grow increasingly large across a fuzzing campaign with billions of executions and even more packets exchanged. Additionally, even recordings across long interaction chains may not suffice if the target does not always behave predictably. To mitigate this challenge, \proj restarts Zephyr before each trace evaluation, trading off the additional runtime for increased simplicity and reliability, and reduced memory and storage consumption.
    \item The trace to be mutated needs to contain all previous interaction with the PUT, which put it into a certain state, in addition to the last packet the fuzzer attempts to trigger an error with. Section~\ref{Implementation:InputModelling} presents different approaches evaluated in this project.
  \end{enumerate}

  \subsection{LibAFL}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Related Works%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Related Works}
  \label{RelatedWorks}
  \begin{itemize}
    \item Focus on Network Protocol Fuzzing
  \end{itemize}

  \subsection{Protocol Fuzzing}
  \subsubsection{Observing State}
  \begin{itemize}
    \item Manual annotation
    \item Automatic annotation
    \item Other greybox approaches
    \item Heuristics
  \end{itemize}

  \subsubsection{Use of State Information}
  \begin{itemize}
    \item Feedback/Maximization
    \item Scheduling
  \end{itemize}

  \subsubsection{Input Modelling and Mutation}


  \subsection{Snapshotting}


  \subsection{Data, TODO: Integrate}
  \begin{itemize}
    \item \citetitle{StatefulGreybox}\cite{StatefulGreybox}: \textquote{In this paper, we argue that protocols are often explicitly encoded using state variables that are assigned and compared to named constants […] More specifically, using pattern matching, we identify state variables using enumerated types (enums). An enumerated type is a group of named constants that specifies all possible values for a variable of that type. Our instrumentation injects a call to our runtime at every program location where a state variable is assigned to a new value. Our runtime efficiently constructs the state transition tree (STT). The STT captures the sequence of values assigned to state variables across all fuzzer-generated input sequences, and as a global data structure, it is shared with the fuzzer.}\cite{StatefulGreybox} Built on LibFuzzer
    \item \citetitle{StateAFL}\cite{StateAFL}: compile-time probes observing memory allocation and I/O operations; state inference based on fuzzy hashing of long-lived memory areas.
    \item \citetitle{Ijon}\cite{Ijon}: Manual annotations of code, to manually add entries to an AFL-style map (set/inc at calculated offset), include state information (variable values) in how edge coverage is calculated, and store the max value a certain variable reaches during execution for the fuzzer to then maximize.
    \item \citetitle{SandPuppy}\cite{SandPuppy}: Ijon\cite{Ijon}, but automatic (initial run capturing variable-value traces, analyze along with source code, add Ijon-style instrumentation, repeat during fuzzing)
    \item \citetitle{INVSCOV}\cite{INVSCOV}: run for 24 hours, record variable values and relationships between them, then add a feedback that rewards when the generated assertions are violated
    \item \citetitle{Ankou}\cite{Ankou}: take combination of executed branches into consideration, reduce to manageable adaptive fitness function
    \item \citetitle{FuzzFactory}\cite{FuzzFactory}: framework to add custom feedbacks like number of basic blocks executed, amount of memory allocated, etc.
    \item \citetitle{ParmeSan}\cite{ParmeSan}: Use sanitizers checks as fuzzing targets
    \item \citetitle{DDFuzz}\cite{DDFuzz}: Use execution of new data dependencies as feedback
    \item \citetitle{StateFuzz}\cite{StateFuzz}: Find state variables (long-lived, can be updated by users, change control flow or memory access) using static analysis, use that to guide fuzzing (new coverage, new value-range, new extreme value). (Talk: Good Example of why coverage-guided alone is insufficient). Check value ranges instead of all values (static symbex!). 4-digit number of state varia les in linux kernel and Qualcomm MSM kernel (Google Pixel).
    \item \citetitle{ProFuzzBench}\cite{ProFuzzBench}: Suite of 10 protocols and 11 open-source implementations of those to be tested. TCP is notably absent from this list. Certain protocols (like FTP) already return HTTP status codes, others are patched to do so. Dockerized. The authors note that configuration is not taken into account and multi-party ($\geq 3$) protocols can not be fuzzed right now. Non-determinism in the programs make feedback (like code coverage) less predictable and thus fuzzing less performant because it introduces non-differentiable duplicate entries into the corpus. Speed is another issue, where complex setup-processes, costly network operations (resp. synchronization for me), and long multipart-inputs contribute. Finally, state identification is only superficially handled.
    \item \citetitle{AFLNET}\cite{AFLNET}: FTP and RTSP as targets, state transition (+coverage) feedback, corpus from traces, mutation on random entry (havoc and insert/delete/duplicate etc.), corpus scheduling based on statistics about each state.
    \item \citetitle{TCPFuzz}\cite{TCPFuzz}: TCP targets, differential fuzzing, input: syscalls + packets, complex mutators including intelligent dependencies between the current and all previous packets and syscalls in the input, feedback: inter-package diff in coverage.
    \item \citetitle{FitM}\cite{FitM}: Use persistent snapshots of userspace processes (CRIU), fuzzer-in-the-middle, multiple strategies such as input deduplication and resynchronization necessary because of the approach
    \item \citetitle{Autofuzz}\cite{Autofuzz}: Man-in-the-middle, learn protocol by constructing a FSA and packet syntax using a bioinformatics technique. Fuzz server and client.
    \item \citetitle{EPF}\cite{EPF}: Target SCADA, uses population-based simulated annealing to schedule which packet type to add/mutate next in conjunction with coverage feedback. Requires Scapy-compatible implementation of packet types to ensure packet structure.
    \item \citetitle{ModelBased}\cite{ModelBased}: Build FSM and minimize it, then use it to schedule basic mutations.
    \item \citetitle{GANFuzz}\cite{GANFuzz}: Learn GAN to generate next inputs. Targets Modbus-TCP.
    \item \citetitle{StatefulReview}\cite{StatefulReview}: Provides taxonomy of components and categorizes stateful fuzzers, compares approaches and lists challenges and future directions.
    \item \citetitle{Congestion}\cite{Congestion}: Manual FSM from RFC to generate abstract attack models against congestion control implementations, which are then transformed to concrete attacks strategies and tested on actual implementations.
    \item \citetitle{ModbusTCP}\cite{ModbusTCP} is a Modbus fuzzer, that only seems to use TCP as transport. Generation of packets happens only for Modbus itself. \citetitle{MTFStorm}\cite{MTFStorm} is follow-up work that does the same more systematically.
    \item \citetitle{IndustrialReview}\cite{IndustrialReview} review industrial control protocol. Notably, Modbus/TCP fuzzing seems common, but TCP is only used as transport layer, not target.

    \item \citetitle{MTA}\cite{MTA} use machine learning models to generate Modbus/TCP packets, but target Modbus and again only use TCP as a transportation layer.
    \item \citetitle{AnotherModbusTCP}\cite{AnotherModbusTCP} is another Modbus/TCP fuzzer that does not fuzz the TCP stack. See also\cite{ModbusTCP2}.
    \item A similar approach using a Scapy-based fuzzer was implemented for the industrial protocol EtherNet/IP, where TCP was declared as out-of-scope\cite{ENIP}.
    \item \citetitle{StateMachine}\cite{StateMachine} calculate a directed graph from the measured state variables, and schedule mutations based on a formula incorporating state depth, coverage, number of transitions, and number of mutations based on this state.
  \end{itemize}

  \subsubsection{TODO: Read}
  \begin{itemize}
    \item \citetitle{Survey}\cite{Survey}
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Implementation%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Implementation}
  \label{Implementation}

  \subsection{native\_sim}
  During the compilation of Zephyr, a target board has to be set. One such target provided by the Zephyr project is called \code{native_sim}, with which the entire operating system and all user code can be compiled into a Linux executable based on a POSIX architecture. It is based on NativeSimulator, and provides a wrapper around Zephyr with a main function, a scheduler mapping from the host's scheduler to Zephyr's scheduler, hardware models, interrupt controllers, and basic CPU functionality like threading and start/sleep/interrupt calls.\cite{NativeSimulator}. Its integration with Zephyr provides certain functionality to use the host operating system's functionality such as ethernet, UART, or display drivers, among others.\cite{ZephyrNativeSim}

  The ability to run Zephyr as a native executable allows the use of native debugging tools such as \code{gdb} and makes computationally expensive translation layers such as QEMU unnecessary, thus increasing the efficiency of the target. This is especially relevant for a fuzzer since it runs the target millions of times.

  When targeting \code{native_sim}, Zephyr's build system can further be instructed to compile the code using AddressSanitizer (ASAN). This compiler pass instruments the target binary with additional runtime checks for memory errors such as out-of-bounds accesses to heap, stack, or global variables, use-after-free and use-after-return errors, or double frees.\cite{ASAN} Both the default toolchain based on \code{gcc} and the alternate LLVM/\code{clang}-based toolchain provide such instrumentation.

  During this project, I discovered a bug in Zephyr's device registration when using the ASAN implementation of clang, which I needed to use for its superior coverage instrumentation (see Section~\ref{Implementation:SanCov}). I worked together with the maintainers of Zephyr to triage and fix this bug.\cite{ZephyrASANIssue}

  \code{native_sim} allows manipulating the clock of Zephyr, to run the operating system faster or slower than realtime, or disabling any speed restrictions. The latter however renders any \code{sleep}-interrupted loop into one that runs nearly unrestrictedly fast. This in turn leads to near-instant timeouts of connections and is thus unsuitable for interaction with an other system such as the fuzzer. However, passing \code{--rt-ratio=<n>} to the executable built with the target \code{native_sim} allows a user to set the ratio of how quickly Zephyr's virtual time passes compared to real-time.

  \subsection{Coverage Information}
  \label{Implementation:SanCov}

  To guide the fuzzer and measure its progress, \proj measures the executed code under each trace (refer to Section~\ref{Background:Feedback} for more details on coverage feedback). A method commonly used and well-supported by LibAFL to do this is using \code{clang}'s SanitizerCoverage compiler pass. It instruments the code with two functions:

  \begin{lstlisting}[
    language=C++,
    caption={SanitizerCoverage Hook Implementations}
  ]
void __sanitizer_cov_trace_pc_guard_init(
  uint32_t *start,
  uint32_t *stop
) {
  for (uint32_t *x = start; x < stop; x++) {
    *x = 0;
  }
}
void __sanitizer_cov_trace_pc_guard(
  uint32_t *guard
) {
  *guard += 1;
}\end{lstlisting}

  The first is called at program startup and allows initializing a memory section (delimited with \code{start} and \code{stop}). The second is called on each basic block edge, with a guard unique to this edge, pointing in the previously initialized memory section. The implementation above counts how often every edge is executed.

  Initial measurements suggested that the coverage measured when running Zephyr using the \code{native_sim} wrapper is inconsistent, particularly in the code sections responsible for matching host thread to Zephyr thread, the execution of which depends on the (unpredictable) host scheduler. Thus, an alternate implementation of \code{__sanitizer_cov_trace_pc_guard} is used in \proj, which only marks the visited edges as executed, instead of counting the executions, to stabilize the results.

  To prevent additional instability, I reduced the changes to existing logic in both the code and build system to a minimum. To achieve this, my implementations for the SanitizerCoverage functions are in a separate module, which is included in the build system. For this, a single entry is added to the appropriate CMake file and a single option is added to Zephyr's configuration system.

  To increase performance and be more error-resistant, the coverage is directly written into shared memory created by the fuzzer. During the initialization, the shared memory is opened based on information passed through environment variables. Additionally, the information needed to map from the SanitizerCoverage-reserved memory section to the shared memory section is stored. On each edge, the appropriate address in the shared memory section is calculated and marked as visited. While there is a slight performance-penalty on each edge due to the address mapping, this approach does not require any post-processing on the client's part, such as copying the collected information back to the fuzzer. This is particularly important in cases of crashes in the PUT, since any post-processing function would no longer be called.

  \subsection{Network Interfaces}
  \label{Implementation:NetworkInterface}

  Zephyr's \code{native_sim} already provides an ethernet driver for a TAP interface over a zeth interface.\cite{ZephyrNativeSim} However, for this project, I opted to build an alternative solution to circumvent the additional limitations of the host kernel interaction. Instead, I built a custom ethernet driver based that transmits network packets between the fuzzer and target using shared memory.

  As described above, I again wanted to limit the required changes to existing logic as much as possible. To achieve this, the configuration system is extended with an alternative to the existing TAP-based ethernet driver. The new configuration is then used in the appropriate CMake files to include the logic for the shared memory-based ethernet driver. Similar to the existing TAP-based driver, the logic is split into a part compiled into the kernel directly, and one for all interaction with the host system.

  The driver requires a single shared memory segment, the information of which is passed to the PUT using environment variables. There, it is initialized in the driver initialization hook provided by Zephyr. The memory section is split into four parts: one buffer and status field each for each direction. The status field is set to a negative number as long as the buffer is empty, and set to the length of the packet when a packet is sent in either direction. Zephyr's TAP-based driver utilizes sleep-interrupted polling of the network, and so does the shared memory-based implementation.

  Initial experiments showed that certain packets are received at unpredictable intervals or need to be consistently sent to access the TCP logic. The responses to these interactions are manually constructed in the fuzzer and sent to Zephyr. Currently, \proj manually responds to ICMPv6 packets of type NeighborSolicit and RouterSolicit, and to ARP requests for the fuzzer's MAC address.

  \subsection{Input Modelling and Mutation}
  \label{Implementation:InputModelling}

  Section~\ref{Background:FuzzingNetworkStacksIsHard} introduced multiple challenges in fuzzing network stacks in general, and TCP stacks specifically. \proj implements multiple approaches to mitigate some of those challenges, the details of which are discussed here.

  \subsubsection{Trace Modelling and Mutation Target}

  LibAFL provides a composite input type out of the box: \code{MultipartInput}. It consists of a variable number of entries, and for mutation, a random entry is chosen. This is equivalent to the algorithm for selecting which input message to mutate presented in TCP-Fuzz\cite{TCPFuzz}. However, this strategy has one significant intuitive drawback: If the corpus contains a long trace generated across many executions to arrive in a specific state by combining a large number of messages, and the mutation strategy chooses the first message to mutate, the remaining messages are likely going to be irrelevant, because the initial state changes.

  Alternatively, one could approach this problem in a similar fashion to FitM\cite{FitM}. \citeauthor{FitM} essentially build a tree by snapshotting executions and only appending entries. This way, any state can still be reached, but it does not require the fuzzer to needlessly evaluate long traces.

  In \proj, I introduce \code{ReplayingStatefulInput}. It contains a list of messages, and each entry can be mutated in two ways: either a message can be appended (either generated or extracted from another trace), or the \textit{last} entry is mutated. To achieve this, \code{ReplayingStatefulInput::map_mutators} automatically maps any mutator targeting the \textit{message} type to one targeting the \code{trace} type, while also handling empty traces.

  \subsubsection{Seeding}
  \label{Implementation:Seeding}

  Since both options of modelling a trace include mutators appending messages to a trace, one could seed the corpus with a single, empty trace. In principle, the fuzzer will still eventually find its way through the entire state space. However, one can speed up this process greatly with an improved seeding strategy. For this, I first traced an entire full and legal interaction between a client and Zephyr. The trace is then filtered for TCP messages going from the client to the server. Then, the corpus is seeded with slices of this filtered list of messages, starting with the an empty trace and then including increasingly more consecutive messages, all starting with the first filtered message.

  The fuzzer is forced to include \textit{all} traces into its corpus. This is necessary as the server may not respond to every message with an answer, and two traces therefore may look the same to the fuzzer.

  This improved seeding strategy does not diminish the state space the fuzzer is able to explore — the empty trace is still part of the corpus. But it provides the fuzzer with traces ending in many different legal states, thus negating the need for the fuzzer to find its way to deeper states by pure mutation.

  \subsubsection{Input Message Modelling and Mutation}
  Then, there is the question of how to model individual messages. Here, three fundamental approaches could be considered: (1) any representation and exclusive crossover mutations, (2) byte arrays and random mutation, (2) parsed structure with different levels of manual fixing of values after random mutation.

  First, when one only allows crossover mutation of full messages, i.e. appending a message randomly drawn from any other entry in the corpus or a fixed list, how the input is modelled does not matter, since the messages themselves are never changes. However, this approach severely limits the kinds of traces a fuzzer is able to generate and thus unsuitable for general fuzzing.

  Second, one could model a packet as a byte array and mutate it with the default \code{havoc_mutations} from AFL++\cite{AFLPlusPlus}. These include among others byte increments and decrements, bit flips, crossover copying or inserting of subsections of the byte array, setting a byte (combination) to a magic value known for triggering specific types of errors, or deleting parts of the byte array. However, as discussed in Section~\ref{Background:TcpIsStructured}, TCP packets are highly structured and include various checksums. These are unlikely to be calculated correctly by random mutation and thus fuzzers relying on packets generated through \code{havoc_mutations} are not going to be able to explore past the server's code past the initial parsing logic.

  The last option includes modelling a packet as a data structure representing all parts of the raw packet, across all layers. These could then be mutated more selectively. Parts of the packet representing a number can be mutated with number-specific mutators (like setting them to interesting values), bit fields can be mutated as such, and one can fix magic values or checksums manually. This approach represents a tradeoff between the ability to generate a wide range of messages and thus traces, while keeping the generated messages reasonably valid as to not be outright rejected by the parser.

  When employing the third option, one has fine control over what mutations are done by the fuzzer, and what data has to be set manually. One could even allow the fuzzer to mutate checksum or length fields and only overriding the mutated values to the correct ones selectively. This approach tests both all parts of the input parser and still is able to reach the business logic of the TCP stack.

  The drawback of this last option is that it requires the analyst to specify the structure of the network packet. For common protocols such as TCP/IP, there are libraries available, which significantly reduce the required programming overhead, but one still needs to decide which parts of the message should be randomly mutated and which parts should be fixed. The engineering overhead when using LibAFL has been significantly reduced with \code{MappingMutators}, which are discussed in Section~\ref{Implementation:ImprovementsToLibAFL}, along with other improvements to LibAFL implemented during this project.

  \subsection{State Inference Heuristic}
  \label{Implementation:StateInference}

  Section~\ref{Background:TcpIsStateful} discussed how the internal state of the TCP stack is a major challenge for fuzzers. One promising response to mitigate this issue is adding state feedback to the fuzzer. This allows the fuzzer to take into consideration the differences in the state of the PUT's TCP state machine when assessing whether a new trace is worth adding to the corpus.

  To implement this, I mapped incoming messages to a state, represented by a number: Any valid TCP packet is mapped to the \code{u8} representation of its header flag, other packets are mapped to different states representing the alternate packet content (such as packets not containing layer 4 data), or the error source (such as packets with an invalid IP header).

  These state numbers are then used to index into a memory slice representing the TCP state space, similar to how coverage is catalogued in a coverage map. Compared to coverage measurements, one needs to consider that simply counting how often each state is measured, incentives the fuzzer to produce increasingly long traces, even if no new actual state is reached. \proj therefore only marks which states were measured at any point during evaluation of a trace. This further improves reliability, with a similar argument as is presented in Section~\ref{Implementation:SanCov} .

  Section~\ref{Implementation:NetworkInterface} discussed that Zephyr emits certain ICMPv6 packets at unpredictable intervals. To optimize the reliability of state-based feedback, ICMPv6 packets are therefore not mapped to the state memory map.

  Two ways of calculating state-feedback were implemented in \proj :
  \begin{enumerate}
    \item Messages emitted from Zephyr are simply mapped to states, and stored in the state memory map.
    \item Alternatively, the state transition is calculated from an incoming packet and the previous packet, to incentivize the fuzzer to explore all possible state transitions. To implement this, the fuzzer keeps track of previously sent and received messages — since state transitions depend on packets sent both from the client and the server, both directions are taken into account. On each incoming message, \proj calculates a unique identifier for the measured state transition between the current and last packet, which is then used to index the state map. State transitions are only measured for each incoming message, because otherwise, when the fuzzer finds a way to send at least two arbitrary packets without a response, the entire state space would be accounted from fuzzer-emitted packets, while the TCP stack of Zephyr remains in the same state.
  \end{enumerate}

  \subsection{During an Execution: Implementation Details}

  This section describes the details of the implementation of the different parts of \proj. For additional details refer to the architecture diagram of LibAFL in Figure~\ref{fig:LibAFLArchitecture} and their paper\cite{LibAFL} for the interaction of the different structures.

\end{multicols}
\vspace{1em}
\begin{figure}[b]
  \centering
  \includegraphics[width=\textwidth]{assets/LibAFLArchitecture.png}
  \caption{LibAFL's Architecture\cite{LibAFL}}
  \label{fig:LibAFLArchitecture}
\end{figure}
\begin{multicols}{2}

  \subsubsection{Central Infrastructure}

  The fuzzer relies on \code{CentralizedLauncher} to spawn a number of clients, each with their own data structures and each spawning their own instance of Zephyr. \code{CentralizedLauncher} synchronizes inputs that were added to one of the client's corpi to minimize re-execution and combine the progress made across all clients. Two clients are spawned with a different configuration compared to all other clients: The central synchronizing client does not receive a mutational stage, its only job is synchronization. The last client receives additional feedbacks with constant interestingness-values, which report data about the host system, such as available memory, to the monitor.

  Communication between clients is done through Low Level Message Passing (LLMP), a shared memory-based message passing system provided by LibAFL. The absence of a requirement for kernel-based synchronization primitives such as locks allows \proj to effectively scale across thousands of clients.

  Central monitoring is configurable in \proj, but defaults to an \code{OnDiskJsonAggregateMonitor}, which will aggregate data across all clients and log it to a machine-readable file. Additionally, a graphical status-board, and a monitor relaying both a client's logs and aggregated logs to the global logging system are provided. LibAFL further supports more complex logging to different data types or other systems such as a prometheus instance, all of which are easily integrated into \proj.

  \subsubsection{Client Setup and Operation}

  Each client at the start of the fuzzing process initializes its own data structures. These include the following:
  \begin{itemize}
    \item A shared memory section to measure coverage in.
    \item A \code{ConstMapObserver} to handle the coverage, wrapped in a \code{HitcountsMapObserver} for binning postprocessing.
    \item A \code{TimeObserver} to measure execution time.
    \item A \code{PacketObserver} responsible for keeping track of transmitted packets, mapping states to a coverage-like map (refer to Section~\ref{Implementation:StateInference}), and providing all required information for the current execution, such as a has of all packets for deduplication of inputs, the states and state-map for debugging purposes, and a base64-encoded packet capture (pcap) representation of the interaction, to allow graphical tools like Wireshark to be used in debugging.
    \item A \code{StdMapObserver} based on the map from the \code{PacketObserver}, to handle state coverage information.
    \item Combined feedback containing
          \begin{itemize}
            \item \code{MaxMapFeedback}s for both code and state coverage information, the only feedbacks contributing values towards the interesting-ness of the current input.
            \item A \code{PacketMetadataFeedback} attaching the metadata provided by the \code{PacketObserver} to the testcase containing the input.
            \item A \code{TimeFeedback}, \code{InputLenFeedback}, and for the last client host system measuring feedbacks, attaching the execution time, input length, and other information to the metadata.
          \end{itemize}
    \item Two corpi: a \code{InMemoryCorpus} for the working corpus of the fuzzer, and an \code{OnDiskCorpus} for all solutions found.
    \item A \code{StdState} containing a random number generator and the corpi.
    \item The appropriate mutators depending on the selected representation of the trace (see Section~\ref{Implementation:InputModelling}).
    \item \code{StdMOptMutator} is used as a mutator scheduler — it implements the algorithm first presented in MOpt\cite{MOpt}.
    \item A \code{StdMutationalStage} wrapping the mutator scheduler and handling the main mutation workflow.
    \item A \code{StdWeightedScheduler} as an input selection scheduler with a power schedule, as known from AFL++\cite{AFLPlusPlus}.
    \item A \code{ReplayingFuzzer} handling the main fuzzing loop — see below for more details.
    \item A custom \code{Executor} implementing all the necessary logic to interact with Zephyr — see below for more details.
  \end{itemize}

  After setting up all the required data structures, the corpus is filled based on a recorded trace (refer to Section~\ref{Implementation:Seeding}). Because some of the trace subsets result in the same state coverage feedback, but they are still all useful to the fuzzer as starting points from mutations, they are force-generated and afterwards individually evaluated to enhance them with metadata.

  Finally, the main fuzzing loop is started. Here, the fuzzer repeatedly calls the scheduler to select the next corpus entry to be mutated. Then, it calls the mutational stage to repeatedly select how many and which mutations to execute on a copy of the input and calls the evaluator in the fuzzer.

  Here, the additional logic in \code{ReplayingFuzzer} compared to LibAFL's built-in \code{StdFuzzer} comes into play. It sets up a map to store execution results in, and then repeatedly does the following:
  \begin{enumerate}
    \item First, the observers are reset.
    \item Then, the executor is called to execute the input.
    \item After that, postprocessing on observers is done.
    \item The results from the observer, whose results are to be made more reliable, are hashed and combined with the exit status of the execution.
    \item This combination is then used to index into the execution count map, where \code{ReplayingFuzzer} counts how often each result is measured.
    \item If a crash is observed, the fuzzer returns early from the loop to ensure all crashes are caught by the fuzzer.
    \item If the results observed the most have been measured more than a configurable number more often than any other, and the latest execution results in the most common measurements, the execution results are assumed to be "correct" and returned.
    \item If, after a configurable maximum number of executions, the fuzzer is still unable to get a decisive winner, the evaluation is short-circuited and the input is not added to either corpus.
    \item Finally, the measured ratios are stored and reported to the monitor.
  \end{enumerate}

  The executor receives the input, and starts its operation by marking the new run in the fuzzing client state and resetting the packet transmission buffers. Then, Zephyr is spawned in a subprocess with the shared memory information for the coverage and network buffer as environment variables. \proj then waits for Zephyr to startup, while logging packets emitted by it, and only responding to those that require a manual response (see Section~\ref{Implementation:NetworkInterface}).

  After this interaction, the trace is converted to a list of raw byte vectors to be transmitted to Zephyr. One by one, the packets are sent to Zephyr and added to the \code{PacketObserver}. In between sending packets, \proj waits for Zephyr to respond. Since there is currently no way to wait until Zephyr is done with processing an incoming packet, \proj waits until a set time has expired since the last outgoing or incoming packet. During this phase, manual responses are emitted if appropriate. After the last packet was sent and no packet was received for the set timeout, the subprocess running Zephyr is shut down and checked for a crash to be reported.

  \subsubsection{Helper Functionality}
  \proj contains additional logic helpful during development and triage of found issues. First, an implementation of the shared memory-based ethernet driver for the userland network client \code{smoltcp} allows manual interaction with Zephyr through shared memory. Additionally, a set of postprocessing scripts are available, which, among other things, extract pcap files from the corpus, and produce plots as shown in Section~\ref{Results}.

  \subsection{LibAFL}
  \label{Implementation:ImprovementsToLibAFL}

  During this project, I have contributed a range of improvements implemented for \proj as generic version to LibAFL. These include:
  \begin{itemize}
    \item \code{MappingMutator}s are essential for any project using compound input types — they allow mapping mutators targeting a certain type to those where the initial input type can be extracted from using custom logic. One such example would be applying \code{havoc_mutations} to the payload field of the TCP packet.\footnote{Currently, only non-crossover mutations are supported in \proj, because of a limitation in LibAFL with using nested \code{MappingMutator}s. This is required to map mutators from their raw target type (such as byte array or number) to the parsed input structure and then again to the composite type such as \code{ReplayingStatefulInput}.}
    \item \code{CentralizedLauncherBuilder::overcommit} and \code{LauncherBuilder::overcommit} allows users to launch multiple fuzzing clients per CPU core. This is useful in specific projects like \proj, where an individual client does not fully load a CPU core because of wait states necessary for e.g. synchronization.
    \item \code{int_mutators} include the applicable mutators from \code{havoc_mutations} targeting numeric types.
    \item \code{BoolMutator}s flip boolean values.
    \item \code{ValueInput}, an improvement to how inputs encapsuling a simple data type are implemented.
    \item A set of macros for mapping and combining mutator lists and their types.
    \item Improved flexibility for certain schedulers to work on any observer.
    \item \code{OnDiskJsonAggregateMonitor} logs the data aggregated across all fuzzing clients at a certain interval to a file containing machine-readable data.
    \item Several bugfixes related to \code{MultipartInput}.
    \item Several general architectural and clean-code improvements.
    \item \code{StdFuzzer::with_bloom_input_filter}, an improvement to \code{StdFuzzer} which uses a probabilistic filter to reduce repeated execution of the same input\footnote{Not currently used in \proj.}
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Evalutation & Results %%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Evaluation and Results}
  \label{Results}

  \subsection{Consistency, Timeouts, and Real Time}

  \begin{itemize}
    \item \code{StdScheduler} instead of \code{StdWeightedScheduler}, to test across a wider range of inputs
    \item \code{ReplayingFuzzer} with a minimal count difference of 100, a minimum factor difference of 1.5, and maximal 1500 tries
  \end{itemize}

  \subsection{Throughput and Overcommit}

  \subsection{Input Modelling and Mutation}
  With fixed feedback:

  \begin{itemize}
    \item \code[Rust]{MultipartInput} and \code[Rust]{havoc_mutations()}
    \item \code[Rust]{ReplayingStatefulInput} and \code[Rust]{havoc_mutations()}
    \item \code[Rust]{ReplayingStatefulInput} and parsed structure with different mutators
  \end{itemize}

  \subsection{Feedback}
  \begin{itemize}
    \item Coverage (repeatability!)
    \item State marking
    \item State diff marking
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Discussion %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Discussion}
  \label{Discussion}

  \subsection{Feedback}
  \begin{itemize}
    \item How effective do different improvements seem to be
  \end{itemize}
  \subsection{Input Modelling and Mutation}
  \begin{itemize}
    \item How effective do different improvements seem to be
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Conclusion %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Conclusion}
  \label{Conclusion}
  \subsection{Future Work}\todo{move to discussion?}
  \subsubsection{Improved Performance}
  \begin{itemize}
    \item This was not prioritized further because memory was the limiting factor
    \item Semaphores instead of busy waiting
  \end{itemize}
  \subsubsection{Alternate Targets}
  \begin{itemize}
    \item Other OS network stacks
    \item Userland network stacks
  \end{itemize}
  \subsubsection{Improved Oracles}
  \begin{itemize}
    \item e.g. Differential Fuzzing
    \item Sanitizers
  \end{itemize}
  \subsubsection{Improved Scheduling Based on State Feedback}
  \subsubsection{Generilazation of Techniques}
  \subsubsection{Extended Evaluation}
  \begin{itemize}
    \item System calls
    \item IPv6
    \item Other network protocols
    \item Comparison to other fuzzers (not done because none were applicable without extensive engineering work to ensure compatibility with target)
  \end{itemize}

  \subsection{Contributions}
  \begin{itemize}
    \item Summary of paper
  \end{itemize}

\end{multicols}
\vspace{30px}
\begin{center}
  \begin{minipage}{0.75\textwidth}
    \centering
    In the interest of open science, the source code and all artifacts produced during this project are publicly available and released under an open-source license. During development, thousands of lines of code have been introduced to multiple upstream projects. All artifacts produced for this project are available at

    \vspace{8px}

    \href{https://github.com/riesentoaster/fuzzing-zephyr-network-stack}{github.com/riesentoaster/fuzzing-zephyr-network-stack}.
  \end{minipage}
\end{center}

\vspace{50px}

\begin{multicols}{2}
  \defbibheading{bibliography}[\bibname]{\section*{#1}}
  \addcontentsline{toc}{section}{\bibname}
  \printbibliography
\end{multicols}

\end{document}
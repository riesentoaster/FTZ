\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage{csquotes}
\usepackage[vmargin=25mm, hmargin=20mm]{geometry}
\usepackage{lipsum}
\usepackage[table]{xcolor}
\usepackage{easy-todo}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{hhline}
\usepackage{caption}
\captionsetup[table]{hypcap=false}

% \usepackage{float}
% \usepackage{pgfplots}
% \usepgfplotslibrary{colorbrewer}
% \pgfplotsset{compat = 1.18} 
% \usetikzlibrary{pgfplots.statistics, pgfplots.colorbrewer} 
% \usepackage{pgfplotstable}
\usepackage{listings}
\lstset{
    backgroundcolor=\color[RGB]{240, 240, 240},   
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    aboveskip=10pt
}
\usepackage{listings-rust}

\renewcommand{\footnoterule}{%
  \kern 10pt % Increased spacing above delimiter
  \hrule width 0.8\columnwidth
  \kern 5pt
}

\usepackage[
    backend=biber,
    sorting=none,
    style=ieee,
    urldate=long,
    maxcitenames=2,
    mincitenames=1
]{biblatex}
\addbibresource{sources.bib}
\renewcommand*{\bibfont}{\footnotesize}

\usepackage{multicol}
\setlength{\columnsep}{13mm}

% \usepackage{hypcap}
% \usepackage{caption}
% \captionsetup{
%     justification=centerlast,
%     font=small,
%     labelfont=sc,
%     margin=5pt,
%     belowskip=15pt
% }
% \DeclareCaptionType{listing}[Listing][List of Listings]

\title{%
    \vspace{50px}%
    \Huge \proj : A Stateful Fuzzer for the TCP/IP Stack\\of Zephyr
    \vspace{250px}%
}

\author{%
    Valentin Huber\vspace{5px}\\%
    \small at \href{https://www.cydcampus.admin.ch/}{Cyber Defence Campus}\\%
    \small and \href{https://www.zhaw.ch/en/engineering/institutes-centres/init/}{Institute of Computer Science at ZHAW}\\%
    \small \href{mailto://contact@valentinhuber.me}{contact@valentinhuber.me}%
    \vspace{10px}
}

\date{\today}

\DeclareFieldFormat*{citetitle}{\textit{#1}}
\hfuzz=50px
\hbadness=10000
\newcommand{\code}[2][]{\lstinline[language=#1, breaklines=false, basicstyle=\ttfamily]{#2}}
\newcommand{\proj}{FTZ\xspace}
\let\savedCite=\cite
\renewcommand{\cite}{\unskip~\savedCite}
\renewcommand{\arraystretch}{1.5} % Increase table padding


\begin{document}
\pagenumbering{gobble}
\maketitle

\clearpage\newpage
\begin{center}
  \begin{minipage}{0.8\textwidth}
    \vspace{70px}

    \begin{abstract}
      \lipsum[1]\lipsum[2]\lipsum[3]
    \end{abstract}
  \end{minipage}

  \vspace{70px}

  \begin{minipage}{0.7\textwidth}
    \textbf{Keywords}: Software Testing, Fuzzing, Stateful Fuzzing, Zephyr, LibAFL.
  \end{minipage}
\end{center}

\clearpage\newpage
% \clearpage\newpage

\begin{multicols}{2}
  \tableofcontents
  % \vspace{30px}
  \pagenumbering{arabic}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Introduction %%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Introduction}
  \label{Introduction}

  Zephyr is an open-source real-time operating system (OS) hosted by the Linux Foundation.\cite{ZephyrAbout} Real-time OSs allow programers to define time constraints on their code, which are then guaranteed by the process scheduler. To do this, processes have to be verifiably complete within a constant maximal time or fail safely. This is particularly important for safety-critical systems where delays in computation can pose serious risk, such as control of a robot.\cite{RTOSWiki} Zephyr is used in a wide range of products, including large industrial equipments such as wind turbines, medtech devices such as hearing aids, laptops, or embedded devices such as emergency water detectors.\cite{ZephyrUsedIn}

  Zephyr projects typically connect to other devices or the internet using one of the OS's networking libraries, such as a custom-built TCP/IP stack. Since many of these devices need access to the internet, any defect in the network stack is comparatively likely to be remotely exploitable and thus critical. In combination with the potentially dangerous devices Zephyr runs on, this makes the correctness of these parts of Zephyr paramount.\todo{Too much opinion?}

  Fuzzing has been established as a widely used technique\cite{Demystifying} to find software defects by repeatedly running a certain program under test (PUT) with a wide range of inputs and observing the execution for illegal program states such as crashes. It has been applied to great effect: Windows requires dominant software to be fuzzed prior to release\cite{Demystifying}, and its fuzzer SAGE\cite{SAGE} \textquote{reportedly found a third of the Windows 7 bugs between 2007-2009}\cite{FuzzingTheStateOfTheArt}. Google admitted to finding 20,000 vulnerabilities in Chrome alone using fuzz testing\cite{Demystifying}, while its OSS-Fuzz program continuously fuzzing open-source software has resulted in over 6,500 vulnerabilities and 21,000 functional bugs fixed across 500 critical projects\cite{ClusterFuzzLite}.

  Ever since its inception in the nominal work by \citeauthor{UNIX}\cite{UNIX}, who used random data to test Unix utilities, many improvements to fuzzing have been introduced to the state of the art. Among many others (Google Scholar retrieves more than 60,000 results in a search for \textquote{fuzz testing}\cite{GoogleScholarFuzzing}) include observing the program execution to guide the fuzzer when selecting the next input to test, or improved oracles such as memory sanitizers. Section~\ref{Background:MutationalFuzzing} provides additional background on specific fuzzing technique employed in this project called mutational fuzzing.

  However, fuzzing the network stack of an operating system poses three additional challenges: (1) they are deeply integrated with the OS, (2) they require highly structured input data, and (3) they have internal state. These challenges are further elaborated in Section~\ref{Background:FuzzingNetworkStacksIsHard}.

  For this thesis, I developed a proof-of-concept Fuzzer targeting the TCP/IP stack of Zephyr (\proj), built on top of the fuzzing library LibAFL. \proj uses advanced input representation and mutation techniques, stateful feedback, and reliability-enhancing logic to effectively test Zephyr. The remainder of this thesis is structured as follows:

  \begin{itemize}
    \item Section~\ref{Background} presents further background on fuzzing in general and targeting TCP/IP systems in particular,
    \item Section~\ref{RelatedWorks} explores related works,
    \item Section~\ref{Implementation} explains the different techniques used in \proj, along with how they were implemented,
    \item Section~\ref{Results} presents the results achieved in the evaluation of \proj,
    \item Section~\ref{Discussion} discusses the implication of those results on the effectiveness of \proj, and
    \item Section~\ref{Conclusion} summarizes the findings of this thesis.
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Background %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Background}
  \label{Background}

  This section presents additional background information required to understand the remainder of this thesis.

  \subsection{Mutational Fuzzing}

  \label{Background:MutationalFuzzing}
  \proj implements mutational fuzzing. This is a technique use across a wide range of influential fuzzers, such as AFL++\cite{AFLPlusPlus}, syskaller\cite{syskaller}, libFuzzer\cite{libFuzzer}, Honggfuzz\cite{hongfuzz}, or OSS-Fuzz\cite{OSSFuzz}. A mutational fuzzer maintains a corpus of inputs, first seeded at startup with a number of entries that are either generated randomly or loaded from a predefined set. The fuzzer then iteratively chooses one of the inputs in its corpus, mutates it in some way, and evaluates it in the PUT.

  During the execution, mutational fuzzers observe the PUT in certain ways, such as by collecting information about which parts of the PUT's code were executed. These fuzzers are also known as greybox fuzzers â€” a mixture between blackbox fuzzers, which do not know anything about the internals of the PUT during the execution, and whitebox fuzzers, which further analyze the executed logic using symbolic execution or taint analysis.\cite{EVA}\todo{Can I just cite my own work here?}

  The data observed during target execution is then used to decide if the current input should be added back into the corpus. The most common form of such feedback is coverage-guided fuzzing, which adds an input to the corpus if new coverage was measured in the PUT. This incentivizes the fuzzer to explore previously untested parts of the PUT.\cite{AFLPlusPlus}

  \subsection{Fuzzing Network Stacks Is Hard}
  \label{Background:FuzzingNetworkStacksIsHard}

  As introduced in Section~\ref{Introduction}, fuzzing an operating system's network stack introduces three additional challenges.

  \subsubsection{Deep integration with OS}

  OS' built-in network stacks are deeply integrated with other subsystems, such as the memory management subsystem for accessing the network interface card and socket buffers, the system call-based API thought the virtual filesystem. It further relies on the system's scheduler for event notifications. Extracting the network stack from the rest of the kernel to be run independently is therefore infeasible, since it would require extensive additional engineering, which is error-prone and may result in findings that do not hold on the original implementation.\cite{KernelVsUserNetworking}

  To test the network stack of an operating system using a fuzzer, one therefore has to run the entire operating system, which includes a lot of logic unrelated to the network stack itself, thus introducing a significant performance penalty. This further means that any sanitizer has to be introduced into the OS' build system, which may not be possible because the additional logic may break assumptions made by the OS developers (see Section~\ref{Implementation:native_sim}). Finally, OS' kernels are by definition tightly integrated with hardware, and running an operating system therefore requires either dedicated hardware (which may be hard to observe and communicate with), or some form of hardware and environment simulation, introducing additional performance penalties.

  \subsubsection{Network Packets Are Highly Structured}
  \label{Background:TcpIsStructured}

  Table~\ref{Table:NetworkPacket} shows the structure of a packet, as it would be used to seed \proj's corpus with. Many of the fields across all layers depend on values of other fields in their own or even other layers. Examples of these include length fields marked with green or checksums marked with blue. Checksums such as the CRC32 frame check sequence in the ethernet trailer or the 16-bit one's compliment-based checksums in the IPv4 and TCP headers are a prime example of logic fuzzers struggle to penetrate. This is because mutating one part of the data requires very specific changes to another, which is highly unlikely to happen in random mutation.\cite{StateOfTheArt} This challenge has garnered some attention from previous work, such as removing the program sections responsible for checking checksums from the target program\cite{TFuzz}, or bypassing them\cite{REDQUEEN}.

  The sequence and acknowledgment numbers in the TCP header are dependent not only on the current packet, but on previously sent packets. Similarly, the TCP header flags have different meaning depending on the state of the recipient's TCP stack.

  \subsubsection{TCP Stacks Have Internal State}
  \label{Background:TcpIsStateful}

  The fact that TCP is a stateful protocol increases the state space to be explored by the fuzzer dramatically, and the fuzzer may find it hard to reach 'deeper' states.\cite{StatefulReview} Indeed, stateful targets are listed among the remaining challenges in fuzzing by \citeauthor{ChallengesAndReflections} in their review paper.\cite{ChallengesAndReflections} \citeauthor{SGFuzz} demonstrate that simply relying on coverage information is insufficient to fully test stateful code, but the state of the target has to be taken into account.\cite{SGFuzz} A similar conclusion was drawn during the evaluation of StateFuzz.\cite{StateFuzz}

  TCP being a stateful protocol introduces two fundamental challenges to the architecture of the fuzzer:
  \begin{enumerate}
    \item To retain the ability to triage the software error found by the fuzzer, one needs the ability to repeatedly cause the same error. Since the PUT may be put into different states with each message, this means all previous interaction with a PUT instance need to be recorded, records which may grow increasingly large across a fuzzing campaign with billions of executions and even more packets exchanged. Additionally, even recordings across long interaction chains may not suffice if the target does not always behave predictably. To mitigate this challenge, \proj restarts Zephyr before each trace evaluation, trading off the additional runtime for increased simplicity and reliability, and reduced memory and storage consumption.
    \item The trace to be mutated needs to contain all previous interaction with the PUT, which put it into a certain state, in addition to the last packet the fuzzer attempts to trigger an error with. Section~\ref{Implementation:InputModelling} presents different approaches evaluated in this project.
  \end{enumerate}

  {
  \vspace{1em}
  \centering\small
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Layer}                & \textbf{Field}                             & \textbf{Size}               \\\hline
    \multirow{4}{4em}{Ethernet}
                                  & Destination MAC                            & 6 bytes                     \\\hhline{|~|-|-|}
                                  & Source MAC                                 & 6 bytes                     \\\hhline{|~|-|-|}
                                  & \cellcolor{gray!20}802.1Q VLAN Tag         & \cellcolor{gray!20}4 bytes  \\\hhline{|~|-|-|}
                                  & EtherType                                  & 2 bytes                     \\\hhline{|-|-|-|}
    \multirow{12}{4em}{IPv4}      & Version                                    & 4 bit                       \\\hhline{|~|-|-|}
                                  & \cellcolor{green!10}Internet Header Length & \cellcolor{green!10}4 bit   \\\hhline{|~|-|-|}
                                  & DSCP \& ECN                                & 1 byte                      \\\hhline{|~|-|-|}
                                  & \cellcolor{green!10}Total Length           & \cellcolor{green!10}2 bytes \\\hhline{|~|-|-|}
                                  & Identification                             & 2 bytes                     \\\hhline{|~|-|-|}
                                  & Flags \& Fragment Offset                   & 2 bytes                     \\\hhline{|~|-|-|}
                                  & Time To Live                               & 1 byte                      \\\hhline{|~|-|-|}
                                  & Protocol                                   & 1 byte                      \\\hhline{|~|-|-|}
                                  & \cellcolor{blue!10}Header Checksum         & \cellcolor{blue!10}2 bytes  \\\hhline{|~|-|-|}
                                  & Source IP                                  & 4 bytes                     \\\hhline{|~|-|-|}
                                  & Destination IP                             & 4 bytes                     \\\hhline{|~|-|-|}
                                  & \cellcolor{gray!20}Options                 & \cellcolor{gray!20}variable \\\hhline{|-|-|-|}
    \multirow{9}{4em}{TCP}        & Source Port                                & 2 bytes                     \\\hhline{|~|-|-|}
                                  & Destination Port                           & 2 bytes                     \\\hhline{|~|-|-|}
                                  & \cellcolor{green!10}Sequence Number        & \cellcolor{green!10}4 bytes \\\hhline{|~|-|-|}
                                  & \cellcolor{green!10}Acknowledgment Number  & \cellcolor{green!10}4 bytes \\\hhline{|~|-|-|}
                                  & Data Offset \& Reserved                    & 1 byte                      \\\hhline{|~|-|-|}
                                  & Flags                                      & 1 byte                      \\\hhline{|~|-|-|}
                                  & Window                                     & 2 bytes                     \\\hhline{|~|-|-|}
                                  & \cellcolor{blue!10}Checksum                & \cellcolor{blue!10}2 bytes  \\\hhline{|~|-|-|}
                                  & Urgent Pointer                             & 2 bytes                     \\\hhline{|~|-|-|}
                                  & \cellcolor{gray!20}Options                 & \cellcolor{gray!20}variable \\\hhline{|-|-|-|}
    \multicolumn{2}{|l|}{Payload} & variable                                                                 \\\hhline{|-|-|-|}
    Ethernet                      & \cellcolor{blue!10}Frame Check Sequence    & \cellcolor{blue!10}4 bytes  \\\hline
  \end{tabular}
  \captionof{table}{Structure of a network package as used during seeding of \proj. Gray fields are optional, green fields length-dependent, and blue fields checksums.}
  % \todo{move table}
  \label{Table:NetworkPacket}
  \vspace{1em}
  }

  \citeauthor{StatefulReview} introduce a taxonomy of stateful fuzzing in which they define a stateful system as \textquote{a system that takes a sequence of messages as input, producing outputs along the way, and where each input may result in an internal state change}\cite{StatefulReview}. TCP stacks are such a stateful system. This thesis will follow the naming convention outlined in their same work, reserving \textquote{the term message or input message for the individual input that the System Under Test (SUT) consumes at each step and the term trace for a sequence of such messages that make up the entire input.}\cite{StatefulReview}

  \subsection{LibAFL}

  LibAFL is a fuzzing library written in Rust by the maintainers of AFL++. They have observed how many different fuzzers implement similar patterns and data structures, or even fork an existing fuzzer, but only change one specific part of the fuzzer. However,  their improvements rarely get implemented in the upstream fuzzer. This leaves the fuzzing community with a list of provably effective algorithms implemented in incompatible projects. LibAFL provides generic interfaces for common functionality such as schedulers or mutators and default basic default implementation of each.
  Additionally, many advanced algorithms such as the mutation scheduler from MOpt\cite{MOpt}, the weighted input scheduler from AFL++\cite{AFLPlusPlus}, Hitcount coverage postprocessing from AFL\cite{AFL}, or execution-dependent mutation from REDQUEEN\cite{REDQUEEN} have been added. In\citedate{LibAFL}, when LibAFL was released, improvements from 20 prior works were implemented and evaluated individually and in combination. Since then, additional algorithms and improvements have been introduced to make LibAFL a powerful and flexible base for \proj. Section~\ref{Implementation} presents the details of how LibAFL is used in \proj.\cite{LibAFL}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Related Works%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Related Works}
  \label{RelatedWorks}

  \subsection{Fuzzing Zephyr}

  I was unable to find scientific work evaluating fuzz testing on Zephyr. There are however reports of fuzzing campaigns available, listed and compared to \proj here:

  Zephyr has an integration to test parts of the software that are callable from user code using libFuzzer. Compilation of an instrumented version of the OS and linking with libFuzzer is possible with a simple build system configuration entry. However, the example project used as an explanation in Zephyr's documentation does not contain any kernel logic and instead dummy code showing the abilities of coverage-guided fuzzing.\cite{ZephyrFuzzing, ZephyrFuzzingSample}

  There is also an adaption of this example that allows using FuzzBuzz as the fuzzer backing the execution instead of libFuzzer.\cite{ZephyrFuzzBuzz}

  According to \cite{Renode}, the libFuzzer integration has successfully been used to test Zephyr's bluetooth stack. While the blog post mentioning the campaign claims that it helped finding several bugs, it does not provide any detail about the campaign, employed techniques, or evaluation. Besides targeting a different part of Zephyr, it uses libFuzzer, which is a pure coverage-guided fuzzer without any state feedback, so this campaign likely did not use state feedback.

  The blog post further describes using the Renode hardware systems simulator in combination with AFL\cite{AFL} and AFL++\cite{AFLPlusPlus} to fuzz Zephyr, specifically the \code{console/echo} sample. An artificial bug is introduced into the sample code, which will result in a segmentation fault if a certain character is passed to Zephyr. Renode hooks are used to pass data to Zephyr through an emulated UART interface. Custom scripts are required to facilitate the communication between AFL++, Renode, and Zephyr. The setup described in this blogpost describes the alternative way of fuzzing compared to \proj: emulation. Section~\ref{Implementation:native_sim} provides the reasoning behind \proj's different approach. Compared to \proj, AFL and AFL++, as used in this project, only support coverage feedback as opposed to \proj's state feedback.\cite{Renode}

  Finally, \citeauthor{ZephyrFuzzCI} discuss fuzzing Zephyr projects in a continuous integration environment. However, their work is not publicly accessible and the available information about their work does not provide information about technical details of their approach.\cite{ZephyrFuzzCI}

  \subsection{Stateful Protocol Fuzzing}

  The wider field of protocol fuzzing has received considerable attention. I have selected a set of works deemed relevant to the potential improvements implemented and evaluated in \proj.\todo{Do I need a more precise argument for when to include a paper?}

  While not strictly being related work, the review paper by \citeauthor{StatefulReview}\cite{StatefulReview} provide an overview of the state of the art, along with a taxonomy of components of and categorization of stateful fuzzers. It further compares approaches and lists challenges and future directions.

  \subsubsection{Observing State}

  As described in Section~\ref{Background:TcpIsStateful}, a key challenge in fuzzing implementations of participants to stateful protocols is providing information about this state back to the fuzzer to then be used. Extracting this information from a PUT has been achieved using various techniques across projects:

  \paragraph{Manual Annotation}

  Ijon\cite{Ijon} is an extension to AFL and requires analysts to manually annotate the PUT's code. Ijon introduces logic at the annotated location to add entries to an AFL-style map, in either a tainting or counting mode. It can further directly include state information such as variable values in how the edge coverage is calculated, and store the maximum value a certain variable reaches during execution for the fuzzer to then maximize back in the fuzzer. However, the only target Ijon is evaluated on and resembling a protocol is the CROMU\_00020 target of the Darpa Cyber Grand Challenge, which requires inferring the state of the target to successfully trigger the error. There, Ijon showed improved performance compared to unmodified AFL.

  \paragraph{Automatic Annotation}

  Manual annotations of state variables is tedious, error-prone, and requires a decent understanding of the PUT internal structure by the analyst. Because of this, many projects attempt to use a heuristic to automatically find variable or memory locations representing the current state of the PUT and passing this information back to the fuzzer.

  \citeauthor{SGFuzz} rely on the intuition that variables representing the state of their target are often assigned from named constants in an enum struct. At all locations updating these variables, instrumentation is injected to pass the information back to the fuzzer.\cite{SGFuzz}

  SandPuppy\cite{SandPuppy} performs an initial run of the PUT, capturing variable-value traces, and uses a heuristic based on this information and static analysis of the source code of the PUT to identify state-representing variables. These are then instrumented with a Ijon-like feedback mechanism. This process is repeated at certain intervals during the fuzzing campaign.Compared to Ijon, minor improvements were achieved, such as additional solved Super Mario Bros levels. It further shows that state feedback generally improves achieved coverage compared to pure coverage-guided fuzzers such as AFL, AFL++, or REDQUEEN, and even compared to the heuristic to identify state-representing variables in SGFuzz.

  StateFuzz\cite{StateFuzz} identifies state-representing memory by looking for variables that are long-lived, updatable by the user, and either change the control flow or are used to index into memory. StateFuzz identified a four digit number of state variables in the Linux and Qualcomm MSM kernel used in Google's Pixel line of smartphone.

  \paragraph{Other Greybox Heuristics}

  StateAFL\cite{StateAFL} relies on compile-time probes observing memory allocation and I/O operations to identify state-representing memory locations. State inference is then done based on fuzzy hashing of long-lived memory areas. Their approach proves effective, even compared to other state-aware fuzzers such as AFLNet.

  TCP-Fuzz\cite{TCPFuzz} and Ankou\cite{Ankou} take the combination of executed branches as a heuristic for the state of the target. Because this approach leads to a number of states much larger than the states of the abstract state machine powering the server (TCP-Fuzz found 47.9K state transitions in the TCP stack mTCP), Ankou further reduces this complexity for a custom adaptive fitness function.

  \subsubsection{Use of State Information}
  \todo{write something here}
  \paragraph{Feedback}

  In mutational fuzzers, state information can be used in several ways to decide whether an input should be considered interesting and thus added to the corpus. Examples of this includes StateFuzz\cite{StateFuzz}, which considers inputs interesting that trigger additional, previously unchanged states, state values representing a new value range, or new extreme values. Value ranges are binned values of states determined to be congruent using symbolic execution. AFLNet\cite{AFLNET} allows users to specify that not only states but also state-transitions should be use to determine the interesting-ness of an input. DDFuzz\cite{DDFuzz} uses a similar approach, but does not directly rely on state information and instead uses execution of new inter-data dependency relationships as feedback.

  \paragraph{Scheduling}

  The state of the PUT as observed using any of the methods described above can then be used to improve both input and mutator scheduling, as shown by the following approaches:

  Several projects create an abstract data structure representing the state space and possible state transitions of the PUT. This can then be used to improve scheduling. Examples include ZFuzz, which calculates an ad-hoc directed graph based on measured states, while SGFuzz\cite{SGFuzz} constructs a similar data structure called a state transition tree. \citeauthor{ModelBased}\cite{ModelBased} and Autofuzz\cite{Autofuzz} construct a finite state machine, where the latter employs a bioinformatics algorithm and the former minimizes the FSM before using it to schedule the mutators.

  These structures are then used in several ways: AFLNet\cite{AFLNET} uses a custom heuristic based on statistics about each state to schedule the next input to be mutated. SGFuzz\cite{SGFuzz} guides the fuzzer to under-explored parts of the state-space by scheduling input traces leaving the PUT in such a state for the next mutation. The structure can further be used to schedule which mutator(s) should be invoked next\cite{ModelBased}. ZFuzz\cite{ZFuzz} does this based on a formula incorporating state depth, coverage, number of transitions, and number of mutations based on this state.

  \subsubsection{Limitations of Existing Protocol Fuzzers in Relation to \proj}

  While all of the projects presented above introduce provably effective approaches to increase a fuzzer's performance on their targets by using state feedback, only TCP-Fuzz\cite{TCPFuzz} has the same target as \proj: TCP/IP stacks.

  Others target BitTorrent\cite{Ankou}, DNS\cite{StateAFL}, FTP \cite{AFLNET, FitM, StateAFL, Autofuzz,ZFuzz}, HTTP2\cite{SGFuzz}, Modbus-TCP\cite{ModbusTCP,ModbusTCP2, GANFuzz, MTA, AnotherModbusTCP}, MSNIM\cite{ModelBased}, RTSP and other media streaming protocols\cite{AFLNET, SGFuzz}, SMTP\cite{StateAFL}, SSH\cite{StateAFL}, or SSL/TLS\cite{SGFuzz,ZFuzz,DDFuzz} libraries, or SCADA systems\cite{EPF}. TCP/IP is used by some of these fuzzers to facilitate communication between the fuzzer and PUT, but not evaluated independently. To compare the effectiveness of improvements introduced by a certain fuzzer, some are further evaluated against mazes\cite{Ijon, SandPuppy}, levels of the game Super Mario Bros\cite{Ijon, SandPuppy}, or file formats with complex data-interdependencies\cite{Ijon, SandPuppy, DDFuzz, Ankou}.

  Thus, comparisons are impossible without reimplementing the logic of either related work for \proj's targets, or the other way around. Additionally, such changes to related works would also need to include the custom logic to exchange packets with the PUT introduced in \proj â€” this also applies to TCP-Fuzz.

  \subsection{Input Modelling and Targeted Specific Mutation}

  Section~\ref{Background:TcpIsStructured} introduced how mutation on inputs that have high data interdependence such as length fields or checksums is one of the core challenges for mutational fuzzers targeting logic processing such inputs. While most protocol fuzzers rely on random mutation, certain works have proposed improvements to better mitigate this issue.

  EPF\cite{EPF} uses population-based simulated annealing to schedule which packet type to add or mutate next in conjunction with coverage feedback. It requires Scapy-compatible implementation of packet types to be fuzzed to ensure packet structure. TCP-Fuzz models the inputs to the TCP/IP stacks tested as a list of system calls and packets, and mutates these lists while ensuring certain constraints between input parts, such as \code{socket}, \code{bind}, \code{listen} and \code{accept} being always called in order if a connection is in a certain state. However, TCP-Fuzz randomly selects which part of the input is mutated next. Since \proj employs a similar technique, it includes the major downside of this approach: the structure of the packets and constraints to be ensured after mutation have to be specified manually.

  Alternatively, approaches such as GANFuzz\cite{GANFuzz} or Autofuzz\cite{Autofuzz} attempt to automatically learn the structure of the inputs based on generative adversarial networks\cite{GANFuzz} or bioinformatics techniques\cite{Autofuzz}.

  \subsection{Machine-in-the-Middle}
  As opposed to other works, FitM\cite{FitM} and Autofuzz\cite{Autofuzz} attempt to fuzz both the server and client implementations of a protocol library through machine-in-the-middle mutation, while relying


  % continue here

  \begin{itemize}
    \item FitM
    \item Autofuzz\cite{Autofuzz}: Man-in-the-middle, Fuzz server and client
  \end{itemize}

  \subsection{Protocols Targeting TCP Stacks}
  \begin{itemize}
    \item \citetitle{GANFuzz}\cite{GANFuzz}: Targets Modbus-TCP.
    \item \citetitle{TCPFuzz}\cite{TCPFuzz}: TCP targets, differential fuzzing, input: syscalls + packets, complex mutators including intelligent dependencies between the current and all previous packets and syscalls in the input, feedback: inter-package diff in coverage. \todo{mention everywhere}
    \item \citetitle{FitM}\cite{FitM}: Use persistent snapshots of userspace processes (CRIU), fuzzer-in-the-middle, multiple strategies such as input deduplication and resynchronization necessary because of the approach\todo{mention everywhere}
    \item   \citetitle{ModbusTCP}\cite{ModbusTCP} is a Modbus fuzzer, that only seems to use TCP as transport. Generation of packets happens only for Modbus itself. \citetitle{MTFStorm}\cite{MTFStorm} is follow-up work that does the same more systematically.
    \item \citetitle{MTA}\cite{MTA} use machine learning models to generate Modbus/TCP packets, but target Modbus and again only use TCP as a transportation layer.
    \item \citetitle{AnotherModbusTCP}\cite{AnotherModbusTCP} is another Modbus/TCP fuzzer that does not fuzz the TCP stack. See also\cite{ModbusTCP2}.
    \item A similar approach using a Scapy-based fuzzer was implemented for the industrial protocol EtherNet/IP, where TCP was declared as out-of-scope\cite{ENIP}.
  \end{itemize}

  \subsection{Data, TODO: Integrate}
  \begin{itemize}
    \item \citetitle{ProFuzzBench}\cite{ProFuzzBench}: Suite of 10 protocols and 11 open-source implementations of those to be tested. TCP is notably absent from this list. Certain protocols (like FTP) already return HTTP status codes, others are patched to do so. Dockerized. The authors note that configuration is not taken into account and multi-party ($\geq 3$) protocols can not be fuzzed right now. Non-determinism in the programs make feedback (like code coverage) less predictable and thus fuzzing less performant because it introduces non-differentiable duplicate entries into the corpus. Speed is another issue, where complex setup-processes, costly network operations (resp. synchronization for me), and long multipart-inputs contribute. Finally, state identification is only superficially handled.
    \item \citetitle{Congestion}\cite{Congestion}: Manual FSM from RFC to generate abstract attack models against congestion control implementations, which are then transformed to concrete attacks strategies and tested on actual implementations.
    \item \citetitle{IndustrialReview}\cite{IndustrialReview} review industrial control protocol. Notably, Modbus/TCP fuzzing seems common, but TCP is only used as transport layer, not target.
  \end{itemize}

  \subsubsection{Probably remove}
  \begin{itemize}
    \item \citetitle{INVSCOV}\cite{INVSCOV}: run for 24 hours, record variable values and relationships between them, then add a feedback that rewards when the generated assertions are violated
    \item \citetitle{ParmeSan}\cite{ParmeSan}: Use sanitizers checks as fuzzing targets
    \item \citetitle{FuzzFactory}\cite{FuzzFactory}: framework to add custom feedbacks like number of basic blocks executed, amount of memory allocated, etc.

  \end{itemize}

  \subsubsection{TODO: Read}
  \begin{itemize}
    \item \citetitle{Survey}\cite{Survey}
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Implementation%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Implementation}
  \label{Implementation}

  \subsection{native\_sim}
  \label{Implementation:native_sim}
  During the compilation of Zephyr, a target board has to be set. One such target provided by the Zephyr project is called \code{native_sim}, with which the entire operating system and all user code can be compiled into a Linux executable based on a POSIX architecture. It is based on NativeSimulator, and provides a wrapper around Zephyr with a main function, a scheduler mapping from the host's scheduler to Zephyr's scheduler, hardware models, interrupt controllers, and basic CPU functionality like threading and start/sleep/interrupt calls.\cite{NativeSimulator}. Its integration with Zephyr provides certain functionality to use the host operating system's functionality such as ethernet, UART, or display drivers, among others.\cite{ZephyrNativeSim}

  The ability to run Zephyr as a native executable allows the use of native debugging tools such as \code{gdb} and makes computationally expensive translation layers such as QEMU unnecessary, thus increasing the efficiency of the target. This is especially relevant for a fuzzer since it runs the target millions of times.

  When targeting \code{native_sim}, Zephyr's build system can further be instructed to compile the code using AddressSanitizer (ASAN). This compiler pass instruments the target binary with additional runtime checks for memory errors such as out-of-bounds accesses to heap, stack, or global variables, use-after-free and use-after-return errors, or double frees.\cite{ASAN} Both the default toolchain based on \code{gcc} and the alternate LLVM/\code{clang}-based toolchain provide such instrumentation.

  During this project, I discovered a bug in Zephyr's device registration when using the ASAN implementation of clang, which I needed to use for its superior coverage instrumentation (see Section~\ref{Implementation:SanCov}). I worked together with the maintainers of Zephyr to triage and fix this bug.\cite{ZephyrASANIssue}

  \code{native_sim} allows manipulating the clock of Zephyr, to run the operating system faster or slower than realtime, or disabling any speed restrictions. The latter however renders any \code{sleep}-interrupted loop into one that runs nearly unrestrictedly fast. This in turn leads to near-instant timeouts of connections and is thus unsuitable for interaction with an other system such as the fuzzer. However, passing \code{--rt-ratio=<n>} to the executable built with the target \code{native_sim} allows a user to set the ratio of how quickly Zephyr's virtual time passes compared to real-time.

  \subsection{Coverage Information}
  \label{Implementation:SanCov}

  To guide the fuzzer and measure its progress, \proj measures the executed code under each trace (refer to Section~\ref{Background:MutationalFuzzing} for more details on coverage feedback). A method commonly used and well-supported by LibAFL to do this is using \code{clang}'s SanitizerCoverage compiler pass. It instruments the code with two functions:

  \begin{lstlisting}[
    language=C++,
    caption={SanitizerCoverage Hook Implementations}
  ]
void __sanitizer_cov_trace_pc_guard_init(
  uint32_t *start,
  uint32_t *stop
) {
  for (uint32_t *x = start; x < stop; x++) {
    *x = 0;
  }
}
void __sanitizer_cov_trace_pc_guard(
  uint32_t *guard
) {
  *guard += 1;
}\end{lstlisting}

  The first is called at program startup and allows initializing a memory section (delimited with \code{start} and \code{stop}). The second is called on each basic block edge, with a guard unique to this edge, pointing in the previously initialized memory section. The implementation above counts how often every edge is executed.

  Initial measurements suggested that the coverage measured when running Zephyr using the \code{native_sim} wrapper is inconsistent, particularly in the code sections responsible for matching host thread to Zephyr thread, the execution of which depends on the (unpredictable) host scheduler. Thus, an alternate implementation of \code{__sanitizer_cov_trace_pc_guard} is used in \proj, which only marks the visited edges as executed, instead of counting the executions, to stabilize the results.

  To prevent additional instability, I reduced the changes to existing logic in both the code and build system to a minimum. To achieve this, my implementations for the SanitizerCoverage functions are in a separate module, which is included in the build system. For this, a single entry is added to the appropriate CMake file and a single option is added to Zephyr's configuration system.

  To increase performance and be more error-resistant, the coverage is directly written into shared memory created by the fuzzer. During the initialization, the shared memory is opened based on information passed through environment variables. Additionally, the information needed to map from the SanitizerCoverage-reserved memory section to the shared memory section is stored. On each edge, the appropriate address in the shared memory section is calculated and marked as visited. While there is a slight performance-penalty on each edge due to the address mapping, this approach does not require any post-processing on the client's part, such as copying the collected information back to the fuzzer. This is particularly important in cases of crashes in the PUT, since any post-processing function would no longer be called.

  \subsection{Exchanging Network Packets with Zephyr}
  \label{Implementation:NetworkInterface}

  Zephyr's \code{native_sim} already provides an ethernet driver for a TAP interface over a zeth interface.\cite{ZephyrNativeSim} However, for this project, I opted to build an alternative solution to circumvent the additional limitations of the host kernel interaction. Instead, I built a custom ethernet driver based that transmits network packets between the fuzzer and target using shared memory.

  As described above, I again wanted to limit the required changes to existing logic as much as possible. To achieve this, the configuration system is extended with an alternative to the existing TAP-based ethernet driver. The new configuration is then used in the appropriate CMake files to include the logic for the shared memory-based ethernet driver. Similar to the existing TAP-based driver, the logic is split into a part compiled into the kernel directly, and one for all interaction with the host system.

  The driver requires a single shared memory segment, the information of which is passed to the PUT using environment variables. There, it is initialized in the driver initialization hook provided by Zephyr. The memory section is split into four parts: one buffer and status field each for each direction. The status field is set to a negative number as long as the buffer is empty, and set to the length of the packet when a packet is sent in either direction. Zephyr's TAP-based driver utilizes sleep-interrupted polling of the network, and so does the shared memory-based implementation.

  Initial experiments showed that certain packets are received at unpredictable intervals or need to be consistently sent to access the TCP logic. The responses to these interactions are manually constructed in the fuzzer and sent to Zephyr. Currently, \proj manually responds to ICMPv6 packets of type NeighborSolicit and RouterSolicit, and to ARP requests for the fuzzer's MAC address.

  \subsection{Input Modelling and Mutation}
  \label{Implementation:InputModelling}

  Section~\ref{Background:FuzzingNetworkStacksIsHard} introduced multiple challenges in fuzzing network stacks in general, and TCP stacks specifically. \proj implements multiple approaches to mitigate some of those challenges, the details of which are discussed here.

  \subsubsection{Trace Modelling and Mutation Target}

  LibAFL provides a composite input type out of the box: \code{MultipartInput}. It consists of a variable number of entries, and for mutation, a random entry is chosen. This is equivalent to the algorithm for selecting which input message to mutate presented in AFLNet\cite{AFLNET} or TCP-Fuzz\cite{TCPFuzz}. However, this strategy has one significant intuitive drawback: If the corpus contains a long trace generated across many executions to arrive in a specific state by combining a large number of messages, and the mutation strategy chooses the first message to mutate, the remaining messages are likely going to be irrelevant, because the initial state changes.

  Alternatively, one could approach this problem in a similar fashion to FitM\cite{FitM}. \citeauthor{FitM} essentially build a tree by snapshotting executions and only appending entries. This way, any state can still be reached, but it does not require the fuzzer to needlessly evaluate long traces.

  In \proj, I introduce \code{ReplayingStatefulInput}. It contains a list of messages, and each entry can be mutated in two ways: either a message can be appended (either generated or extracted from another trace), or the \textit{last} entry is mutated. To achieve this, \code{ReplayingStatefulInput::map_mutators} automatically maps any mutator targeting the \textit{message} type to one targeting the \code{trace} type, while also handling empty traces.

  \subsubsection{Seeding}
  \label{Implementation:Seeding}

  Since both options of modelling a trace include mutators appending messages to a trace, one could seed the corpus with a single, empty trace. In principle, the fuzzer will still eventually find its way through the entire state space. However, one can speed up this process greatly with an improved seeding strategy. For this, I first traced an entire full and legal interaction between a client and Zephyr. The trace is then filtered for TCP messages going from the client to the server. Then, the corpus is seeded with slices of this filtered list of messages, starting with the an empty trace and then including increasingly more consecutive messages, all starting with the first filtered message.

  The fuzzer is forced to include \textit{all} traces into its corpus. This is necessary as the server may not respond to every message with an answer, and two traces therefore may look the same to the fuzzer.

  This improved seeding strategy does not diminish the state space the fuzzer is able to explore â€” the empty trace is still part of the corpus. But it provides the fuzzer with traces ending in many different legal states, thus negating the need for the fuzzer to find its way to deeper states by pure mutation.

  \subsubsection{Input Message Modelling and Mutation}
  Then, there is the question of how to model individual messages. Here, three fundamental approaches could be considered: (1) any representation and exclusive crossover mutations, (2) byte arrays and random mutation, (2) parsed structure with different levels of manual fixing of values after random mutation.

  First, when one only allows crossover mutation of full messages, i.e. appending a message randomly drawn from any other entry in the corpus or a fixed list, how the input is modelled does not matter, since the messages themselves are never changes. However, this approach severely limits the kinds of traces a fuzzer is able to generate and thus unsuitable for general fuzzing.

  Second, one could model a packet as a byte array and mutate it with the default \code{havoc_mutations} from AFL++\cite{AFLPlusPlus}. These include among others byte increments and decrements, bit flips, crossover copying or inserting of subsections of the byte array, setting a byte (combination) to a magic value known for triggering specific types of errors, or deleting parts of the byte array. However, as discussed in Section~\ref{Background:TcpIsStructured}, TCP packets are highly structured and include various checksums. These are unlikely to be calculated correctly by random mutation and thus fuzzers relying on packets generated through \code{havoc_mutations} are not going to be able to explore past the server's code past the initial parsing logic.

  The last option includes modelling a packet as a data structure representing all parts of the raw packet, across all layers. These could then be mutated more selectively. Parts of the packet representing a number can be mutated with number-specific mutators (like setting them to interesting values), bit fields can be mutated as such, and one can fix magic values or checksums manually. This approach represents a tradeoff between the ability to generate a wide range of messages and thus traces, while keeping the generated messages reasonably valid as to not be outright rejected by the parser.

  When employing the third option, one has fine control over what mutations are done by the fuzzer, and what data has to be set manually. One could even allow the fuzzer to mutate checksum or length fields and only overriding the mutated values to the correct ones selectively. This approach tests both all parts of the input parser and still is able to reach the business logic of the TCP stack.

  The drawback of this last option is that it requires the analyst to specify the structure of the network packet. For common protocols such as TCP/IP, there are libraries available, which significantly reduce the required programming overhead, but one still needs to decide which parts of the message should be randomly mutated and which parts should be fixed. The engineering overhead when using LibAFL has been significantly reduced with \code{MappingMutators}, which are discussed in Section~\ref{Implementation:ContributionsToLibAFL}, along with other improvements to LibAFL implemented during this project.

  \subsection{State Inference Heuristic}
  \label{Implementation:StateInference}

  Section~\ref{Background:TcpIsStateful} discussed how the internal state of the TCP stack is a major challenge for fuzzers. One promising response to mitigate this issue is adding state feedback to the fuzzer. This allows the fuzzer to take into consideration the differences in the state of the PUT's TCP state machine when assessing whether a new trace is worth adding to the corpus.

  To implement this, I mapped incoming messages to a state, represented by a number: Any valid TCP packet is mapped to the \code{u8} representation of its header flag, other packets are mapped to different states representing the alternate packet content (such as packets not containing layer 4 data), or the error source (such as packets with an invalid IP header).

  These state numbers are then used to index into a memory slice representing the TCP state space, similar to how coverage is catalogued in a coverage map. Compared to coverage measurements, one needs to consider that simply counting how often each state is measured, incentives the fuzzer to produce increasingly long traces, even if no new actual state is reached. \proj therefore only marks which states were measured at any point during evaluation of a trace. This further improves reliability, with a similar argument as is presented in Section~\ref{Implementation:SanCov} .

  Section~\ref{Implementation:NetworkInterface} discussed that Zephyr emits certain ICMPv6 packets at unpredictable intervals. To optimize the reliability of state-based feedback, ICMPv6 packets are therefore not mapped to the state memory map.

  Two ways of calculating state-feedback were implemented in \proj :
  \begin{enumerate}
    \item Messages emitted from Zephyr are simply mapped to states, and stored in the state memory map.
    \item Alternatively, the state transition is calculated from an incoming packet and the previous packet, to incentivize the fuzzer to explore all possible state transitions. To implement this, the fuzzer keeps track of previously sent and received messages â€” since state transitions depend on packets sent both from the client and the server, both directions are taken into account. On each incoming message, \proj calculates a unique identifier for the measured state transition between the current and last packet, which is then used to index the state map. State transitions are only measured for each incoming message, because otherwise, when the fuzzer finds a way to send at least two arbitrary packets without a response, the entire state space would be accounted from fuzzer-emitted packets, while the TCP stack of Zephyr remains in the same state.
  \end{enumerate}

  \subsection{During an Execution: Implementation Details}

  This section describes the details of the implementation of the different parts of \proj. For additional details refer to the architecture diagram of LibAFL in Figure~\ref{fig:LibAFLArchitecture} and their paper\cite{LibAFL} for the interaction of the different structures.\todo{Move figure}

\end{multicols}
\vspace{1em}
\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{assets/LibAFLArchitecture.png}
  \caption{LibAFL's Architecture\cite{LibAFL}}
  \label{fig:LibAFLArchitecture}
\end{figure}
\begin{multicols}{2}

  \subsubsection{Central Infrastructure}

  The fuzzer relies on \code{CentralizedLauncher} to spawn a number of clients, each with their own data structures and each spawning their own instance of Zephyr. \code{CentralizedLauncher} synchronizes inputs that were added to one of the client's corpi to minimize re-execution and combine the progress made across all clients. Two clients are spawned with a different configuration compared to all other clients: The central synchronizing client does not receive a mutational stage, its only job is synchronization. The last client receives additional feedbacks with constant interestingness-values, which report data about the host system, such as available memory, to the monitor.

  Communication between clients is done through Low Level Message Passing (LLMP), a shared memory-based message passing system provided by LibAFL. The absence of a requirement for kernel-based synchronization primitives such as locks allows \proj to effectively scale across thousands of clients.

  Central monitoring is configurable in \proj, but defaults to an \code{OnDiskJsonAggregateMonitor}, which will aggregate data across all clients and log it to a machine-readable file. Additionally, a graphical status-board, and a monitor relaying both a client's logs and aggregated logs to the global logging system are provided. LibAFL further supports more complex logging to different data types or other systems such as a prometheus instance, all of which are easily integrated into \proj.

  \subsubsection{Client Setup and Operation}

  Each client at the start of the fuzzing process initializes its own data structures. These include the following:
  \begin{itemize}
    \item A shared memory section to measure coverage in.
    \item A \code{ConstMapObserver} to handle the coverage, wrapped in a \code{HitcountsMapObserver} for binning postprocessing.
    \item A \code{TimeObserver} to measure execution time.
    \item A \code{PacketObserver} responsible for keeping track of transmitted packets, mapping states to a coverage-like map (refer to Section~\ref{Implementation:StateInference}), and providing all required information for the current execution, such as a has of all packets for deduplication of inputs, the states and state-map for debugging purposes, and a base64-encoded packet capture (pcap) representation of the interaction, to allow graphical tools like Wireshark to be used in debugging.
    \item A \code{StdMapObserver} based on the map from the \code{PacketObserver}, to handle state coverage information.
    \item Combined feedback containing
          \begin{itemize}
            \item \code{MaxMapFeedback}s for both code and state coverage information, the only feedbacks contributing values towards the interesting-ness of the current input.
            \item A \code{PacketMetadataFeedback} attaching the metadata provided by the \code{PacketObserver} to the testcase containing the input.
            \item A \code{TimeFeedback}, \code{InputLenFeedback}, and for the last client host system measuring feedbacks, attaching the execution time, input length, and other information to the metadata.
          \end{itemize}
    \item Two corpi: a \code{InMemoryCorpus} for the working corpus of the fuzzer, and an \code{OnDiskCorpus} for all solutions found.
    \item A \code{StdState} containing a random number generator and the corpi.
    \item The appropriate mutators depending on the selected representation of the trace (see Section~\ref{Implementation:InputModelling}).
    \item \code{StdMOptMutator} is used as a mutator scheduler â€” it implements the algorithm first presented in MOpt\cite{MOpt}.
    \item A \code{StdMutationalStage} wrapping the mutator scheduler and handling the main mutation workflow.
    \item A \code{StdWeightedScheduler} as an input selection scheduler with a power schedule, as known from AFL++\cite{AFLPlusPlus}.
    \item A \code{ReplayingFuzzer} handling the main fuzzing loop â€” see below for more details.
    \item A custom \code{Executor} implementing all the necessary logic to interact with Zephyr â€” see below for more details.
  \end{itemize}

  After setting up all the required data structures, the corpus is filled based on a recorded trace (refer to Section~\ref{Implementation:Seeding}). Because some of the trace subsets result in the same state coverage feedback, but they are still all useful to the fuzzer as starting points from mutations, they are force-generated and afterwards individually evaluated to enhance them with metadata.

  Finally, the main fuzzing loop is started. Here, the fuzzer repeatedly calls the scheduler to select the next corpus entry to be mutated. Then, it calls the mutational stage to repeatedly select how many and which mutations to execute on a copy of the input and calls the evaluator in the fuzzer.

  Here, the additional logic in \code{ReplayingFuzzer} compared to LibAFL's built-in \code{StdFuzzer} comes into play. It sets up a map to store execution results in, and then repeatedly does the following:
  \begin{enumerate}
    \item First, the observers are reset.
    \item Then, the input is passed to the executor to be run.
    \item After that, postprocessing on observers is done.
    \item The results from the observer, whose results are to be made more reliable, are hashed and combined with the exit status of the execution.
    \item This combination is then used to index into the execution count map, where \code{ReplayingFuzzer} counts how often each result is measured.
    \item Then, the measurements are evaluated as follows:
          \begin{enumerate}[a.]
            \item If a crash is observed, the fuzzer returns early from the loop to ensure all crashes are caught by the fuzzer.
            \item If the results observed the most have been measured more than a configurable number more often than any other, and the latest execution results in the most common measurements, the execution results are assumed to be "correct" and returned.
            \item If, after a configurable maximum number of executions, the fuzzer is still unable to get a decisive winner, the evaluation is short-circuited and the input is not added to either corpus.
          \end{enumerate}
    \item Finally, the measured ratios are stored and reported to the monitor.
  \end{enumerate}

  The executor receives the input, and starts its operation by marking the new run in the fuzzing client state and resetting the packet transmission buffers. Then, Zephyr is spawned in a subprocess with the shared memory information for the coverage and network buffer as environment variables. \proj then waits for Zephyr to startup, while logging packets emitted by it, and only responding to those that require a manual response (see Section~\ref{Implementation:NetworkInterface}).

  After this interaction, the trace is converted to a list of raw byte vectors to be transmitted to Zephyr. One by one, the packets are sent to Zephyr and added to the \code{PacketObserver}. In between sending packets, \proj waits for Zephyr to respond. Since there is currently no way to wait until Zephyr is done with processing an incoming packet, \proj waits until a set time has expired since the last outgoing or incoming packet. During this phase, manual responses are emitted if appropriate. After the last packet was sent and no packet was received for the set timeout, the subprocess running Zephyr is shut down and checked for a crash to be reported.

  \subsubsection{Helper Functionality}
  \proj contains additional logic helpful during development and triage of found issues. First, an implementation of the shared memory-based ethernet driver for the userland network client \code{smoltcp} allows manual interaction with Zephyr through shared memory. Additionally, a set of postprocessing scripts are available, which, among other things, extract pcap files from the corpus, and produce plots as shown in Section~\ref{Results}.

  \subsection{Contributions to LibAFL}
  \label{Implementation:ContributionsToLibAFL}

  During this project, I have contributed a range of improvements implemented for \proj as generic version to LibAFL. These include:
  \begin{itemize}
    \item \code{MappingMutator}s are essential for any project using compound input types â€” they allow mapping mutators targeting a certain type to those where the initial input type can be extracted from using custom logic. One such example would be applying \code{havoc_mutations} to the payload field of the TCP packet.\footnote{Currently, only non-crossover mutations are supported in \proj, because of a limitation in LibAFL with using nested \code{MappingMutator}s. This is required to map mutators from their raw target type (such as byte array or number) to the parsed input structure and then again to the composite type such as \code{ReplayingStatefulInput}.}
    \item \code{CentralizedLauncherBuilder::overcommit} and \code{LauncherBuilder::overcommit} allows users to launch multiple fuzzing clients per CPU core. This is useful in specific projects like \proj, where an individual client does not fully load a CPU core because of wait states necessary for e.g. synchronization.
    \item \code{int_mutators} include the applicable mutators from \code{havoc_mutations} targeting numeric types.
    \item \code{BoolMutator}s flip boolean values.
    \item \code{ValueInput}, an improvement to how inputs encapsuling a simple data type are implemented.
    \item A set of macros for mapping and combining mutator lists and their types.
    \item Improved flexibility for certain schedulers to work on any observer.
    \item \code{OnDiskJsonAggregateMonitor} logs the data aggregated across all fuzzing clients at a certain interval to a file containing machine-readable data.
    \item Several bugfixes related to \code{MultipartInput}.
    \item Several general architectural and clean-code improvements.
    \item \code{StdFuzzer::with_bloom_input_filter}, an improvement to \code{StdFuzzer} which uses a probabilistic filter to reduce repeated execution of the same input\footnote{Not currently used in \proj.}
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Evaluation & Results %%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Evaluation and Results}
  \label{Results}

  \subsection{Consistency, Timeouts, and Real Time}

  \begin{itemize}
    \item \code{StdScheduler} instead of \code{StdWeightedScheduler}, to test across a wider range of inputs
    \item \code{ReplayingFuzzer} with a minimal count difference of 100, a minimum factor difference of 1.5, and maximal 1500 tries
  \end{itemize}

  \subsection{Throughput and Overcommit}

  \subsection{Input Modelling and Mutation}
  With fixed feedback:

  \begin{itemize}
    \item \code[Rust]{MultipartInput} and \code[Rust]{havoc_mutations()}
    \item \code[Rust]{ReplayingStatefulInput} and \code[Rust]{havoc_mutations()}
    \item \code[Rust]{ReplayingStatefulInput} and parsed structure with different mutators
  \end{itemize}

  \subsection{Feedback}
  \begin{itemize}
    \item Coverage (repeatability!)
    \item State marking
    \item State diff marking
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Discussion %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Discussion}
  \label{Discussion}

  \subsection{Feedback}
  \begin{itemize}
    \item How effective do different improvements seem to be
  \end{itemize}
  \subsection{Input Modelling and Mutation}
  \begin{itemize}
    \item How effective do different improvements seem to be
  \end{itemize}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Conclusion %%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Conclusion}
  \label{Conclusion}
  \subsection{Future Work}\todo{move to discussion?}
  \subsubsection{Improved Performance}
  \begin{itemize}
    \item This was not prioritized further because memory was the limiting factor
    \item Semaphores instead of busy waiting
  \end{itemize}
  \subsubsection{Alternate Targets}
  \begin{itemize}
    \item Other OS network stacks
    \item Userland network stacks
  \end{itemize}
  \subsubsection{Improved Oracles}
  \begin{itemize}
    \item e.g. Differential Fuzzing
    \item Sanitizers
  \end{itemize}
  \subsubsection{Improved Scheduling Based on State Feedback}
  \subsubsection{Generilazation of Techniques}
  \subsubsection{Extended Evaluation}
  \begin{itemize}
    \item System calls
    \item IPv6
    \item Other network protocols
    \item Comparison to other fuzzers (not done because none were applicable without extensive engineering work to ensure compatibility with target)
  \end{itemize}

  \subsection{Contributions}
  \begin{itemize}
    \item Summary of paper
  \end{itemize}

\end{multicols}
\vspace{30px}
\begin{center}
  \begin{minipage}{0.75\textwidth}
    \centering
    In the interest of open science, the source code and all artifacts produced during this project are publicly available and released under an open-source license. During development, thousands of lines of code have been introduced to multiple upstream projects. All artifacts produced for this project are available at

    \vspace{8px}

    \href{https://github.com/riesentoaster/fuzzing-zephyr-network-stack}{github.com/riesentoaster/fuzzing-zephyr-network-stack}.
  \end{minipage}
\end{center}

\vspace{50px}

\begin{multicols}{2}
  \defbibheading{bibliography}[\bibname]{\section*{#1}}
  \addcontentsline{toc}{section}{\bibname}
  \printbibliography
\end{multicols}

\end{document}